"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireDefault(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _nodeResolverCore() {
  const data = _interopRequireDefault(require("@parcel/node-resolver-core"));

  _nodeResolverCore = function () {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function errorToThrowableDiagnostic(error, dependency) {
  return new (_diagnostic().default)({
    diagnostic: {
      message: error,
      codeFrames: dependency.loc ? [{
        codeHighlights: [{
          start: dependency.loc.start,
          end: dependency.loc.end
        }]
      }] : undefined
    }
  });
}

var _default = new (_plugin().Resolver)({
  async resolve({
    dependency,
    options,
    specifier,
    pipeline,
    logger
  }) {
    var _dependency$resolveFr, _dependency$meta;

    if (!(0, _utils().isGlob)(specifier)) {
      return;
    }

    let sourceAssetType = (0, _nullthrows().default)(dependency.sourceAssetType);
    let sourceFile = (0, _nullthrows().default)((_dependency$resolveFr = dependency.resolveFrom) !== null && _dependency$resolveFr !== void 0 ? _dependency$resolveFr : dependency.sourcePath);
    let error;

    if (sourceAssetType !== 'js' && sourceAssetType !== 'css') {
      error = `Glob imports are not supported in ${sourceAssetType} files.`;
    } else if (dependency.specifierType === 'url' && !((_dependency$meta = dependency.meta) !== null && _dependency$meta !== void 0 && _dependency$meta.isCSSImport)) {
      error = 'Glob imports are not supported in URL dependencies.';
    }

    if (error) {
      throw errorToThrowableDiagnostic(error, dependency);
    }

    let invalidateOnFileCreate = [];
    let invalidateOnFileChange = new Set(); // if the specifier does not start with /, ~, or . then it's not a path but package-ish - we resolve
    // the package first, and then append the rest of the path

    if (!/^[/~.]/.test(specifier)) {
      // Globs are not paths - so they always use / (see https://github.com/micromatch/micromatch#backslashes)
      let splitOn = specifier.indexOf('/');

      if (specifier.charAt(0) === '@') {
        splitOn = specifier.indexOf('/', splitOn + 1);
      } // Since we've already asserted earlier that there is a glob present, it shouldn't be
      // possible for there to be only a package here without any other path parts (e.g. `import('pkg')`)


      (0, _assert().default)(splitOn !== -1);
      let pkg = specifier.substring(0, splitOn);
      let rest = specifier.substring(splitOn + 1); // This initialisation code is copied from the DefaultResolver

      const resolver = new (_nodeResolverCore().default)({
        fs: options.inputFS,
        projectRoot: options.projectRoot,
        // Extensions are always required in URL dependencies.
        extensions: dependency.specifierType === 'commonjs' || dependency.specifierType === 'esm' ? ['ts', 'tsx', 'js', 'jsx', 'json'] : [],
        mainFields: ['source', 'browser', 'module', 'main'],
        packageManager: options.shouldAutoInstall ? options.packageManager : undefined,
        logger
      });
      let ctx = {
        invalidateOnFileCreate,
        invalidateOnFileChange,
        specifierType: dependency.specifierType,
        loc: dependency.loc,
        range: dependency.range
      };
      let result;

      try {
        result = await resolver.resolveModule({
          filename: pkg,
          parent: dependency.resolveFrom,
          env: dependency.env,
          sourcePath: dependency.sourcePath,
          ctx
        });
      } catch (err) {
        if (err instanceof _diagnostic().default) {
          // Return instead of throwing so we can provide invalidations.
          return {
            diagnostics: err.diagnostics,
            invalidateOnFileCreate,
            invalidateOnFileChange: [...invalidateOnFileChange]
          };
        } else {
          throw err;
        }
      }

      if (!result || !result.moduleDir) {
        throw errorToThrowableDiagnostic(`Unable to resolve ${pkg} from ${sourceFile} when resolving specifier ${specifier}`, dependency);
      }

      specifier = _path().default.resolve(result.moduleDir, rest);
    } else {
      specifier = _path().default.resolve(_path().default.dirname(sourceFile), specifier);
    }

    let normalized = (0, _utils().normalizeSeparators)(specifier);
    let files = await (0, _utils().glob)(normalized, options.inputFS, {
      onlyFiles: true
    });

    let dir = _path().default.dirname(specifier);

    let results = files.map(file => {
      let relative = (0, _utils().relativePath)(dir, file);

      if (pipeline) {
        relative = `${pipeline}:${relative}`;
      }

      return [file, relative];
    });
    let code = '';

    if (sourceAssetType === 'js') {
      let re = (0, _utils().globToRegex)(normalized, {
        capture: true
      });
      let matches = {};

      for (let [file, relative] of results) {
        let match = file.match(re);
        if (!match) continue;
        let parts = match.slice(1).filter(Boolean).reduce((a, p) => a.concat(p.split('/')), []);
        set(matches, parts, relative);
      }

      let {
        value,
        imports
      } = generate(matches, dependency.priority === 'lazy');
      code = imports + 'module.exports = ' + value;
    } else if (sourceAssetType === 'css') {
      for (let [, relative] of results) {
        code += `@import "${relative}";\n`;
      }
    }

    invalidateOnFileCreate.push({
      glob: normalized
    });
    return {
      filePath: _path().default.join(dir, _path().default.basename(specifier, _path().default.extname(specifier)) + '.' + sourceAssetType),
      code,
      invalidateOnFileCreate,
      invalidateOnFileChange: [...invalidateOnFileChange],
      pipeline: null,
      priority: 'sync'
    };
  }

});

exports.default = _default;

function set(obj, path, value) {
  for (let i = 0; i < path.length - 1; i++) {
    let part = path[i];

    if (obj[part] == null) {
      obj[part] = {};
    }

    obj = obj[part];
  }

  obj[path[path.length - 1]] = value;
}

function generate(matches, isAsync, indent = '', count = 0) {
  if (typeof matches === 'string') {
    if (isAsync) {
      return {
        imports: '',
        value: `() => import(${JSON.stringify(matches)})`,
        count
      };
    }

    let key = `_temp${count++}`;
    return {
      imports: `const ${key} = require(${JSON.stringify(matches)});`,
      value: key,
      count
    };
  }

  let imports = '';
  let res = indent + '{';
  let first = true;

  for (let key in matches) {
    if (!first) {
      res += ',';
    }

    let {
      imports: i,
      value,
      count: c
    } = generate(matches[key], isAsync, indent + '  ', count);
    imports += `${i}\n`;
    count = c;
    res += `\n${indent}  ${JSON.stringify(key)}: ${value}`;
    first = false;
  }

  res += '\n' + indent + '}';
  return {
    imports,
    value: res,
    count
  };
}